{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"VESP Wishbone Modules documentation Welcome to the VESP Wishbone Modules documentation. Here you can find information about individual modules, debugging methods and generic information about Wishbone compatibility. Wishbone compatibility Modules are written to be compatible with the Wishbone B4 specification. Some modules support classic non-pipelined, some support pipelined or both. Some modules may support only single transaction cycles. Refer to a documentation of every module. Signal naming Signals are named similarly as in Wishbone specification. This specific naming is determined by a nature of SystemVerilog interfaces -- in ports where direction differs between master and slave, no direction is indicated in the name (except for dat_* signals), because the actual direction is determined by a modport. Here are signal names valid for SLAVE modules: Signal name Wishbone equivalent clk_i CLK_I rst_i RST_I adr ADR_I dat_i DAT_I we WE_I sel SEL_I stb STB_I cyc CYC_I dat_o DAT_O ack ACK_O stall STALL_O Verification and guarantees All blocks are verified using very simple testbench testing basic cases. These testbenches are mainly used as syntax and sanity checks. Some testbenches contain very simple formal property checking, but it is far from ideal. This project does not provide any guarantees. It is not suitable for any production use.","title":"VESP Wishbone Modules documentation"},{"location":"#vesp-wishbone-modules-documentation","text":"Welcome to the VESP Wishbone Modules documentation. Here you can find information about individual modules, debugging methods and generic information about Wishbone compatibility.","title":"VESP Wishbone Modules documentation"},{"location":"#wishbone-compatibility","text":"Modules are written to be compatible with the Wishbone B4 specification. Some modules support classic non-pipelined, some support pipelined or both. Some modules may support only single transaction cycles. Refer to a documentation of every module.","title":"Wishbone compatibility"},{"location":"#signal-naming","text":"Signals are named similarly as in Wishbone specification. This specific naming is determined by a nature of SystemVerilog interfaces -- in ports where direction differs between master and slave, no direction is indicated in the name (except for dat_* signals), because the actual direction is determined by a modport. Here are signal names valid for SLAVE modules: Signal name Wishbone equivalent clk_i CLK_I rst_i RST_I adr ADR_I dat_i DAT_I we WE_I sel SEL_I stb STB_I cyc CYC_I dat_o DAT_O ack ACK_O stall STALL_O","title":"Signal naming"},{"location":"#verification-and-guarantees","text":"All blocks are verified using very simple testbench testing basic cases. These testbenches are mainly used as syntax and sanity checks. Some testbenches contain very simple formal property checking, but it is far from ideal. This project does not provide any guarantees. It is not suitable for any production use.","title":"Verification and guarantees"},{"location":"debugging/","text":"Debugging in simulation For simulation we use Mentor's Questa Sim (formerly known as Modelsim), because Xilinx's xsim was deemed to be insufficient for the project, mainly because of random fatal errors with no further information when using SystemVerilog interface expressions. Other simulators from the 'top 3' should work as well: Synopsys VCS and Cadence Xcelium. To use these, just add appropriate configuration to the FuseSoC core file. Prerequisites The project uses Xilinx's IP. Xilinx's own simulator, xsim, links all of these automatically. However, we use a third-party simulator, Questa Sim, where we need to specify paths to those IPs manually. Sadly all of them are non-public, this means that you need to obtain them by yourself (by default all of them are included in Vivado installation) and edit paths in FuseSoC. Before proceeding, change all paths in xilinx_ip fileset in FuseSoC core file according to your installation. Don't commit these changes. Running a simulation To generate simulation configuration, we use FuseSoC. To run a unit testbench, use target with the name of the unit testbench you want to run (have a look at the wb_modules.core ): fusesoc run --target xpm_ram_tb wb-modules This command will generate a project in build directory and run a simulation. The simulation will output a log to the console and to a transcript file. Also, waveform log will be produced, by default to a vsim.wlf file. This file contains logs of all static signals except memories and is viewable by using command vsim -view vsim.wlf . If you make any changes to the RTL when viewing the log, just relaunch FuseSoC and after the simulation finished, just click Refresh button in vsim; all data will be updated. Debugging classes or memories Note that no class variables (or memories) are logged to the waveform log, unless they are explicitly specified. Some of these are already specified in the FuseSoC core file. To specify more (or newly created classes) or memories, launch the GUI and find signal names. After that, you can continue to debug using the GUI or add the crafted log commands to the FuseSoC config for the signals to be always included in the wlf file. To debug classes/memories with Questa Sim GUI, you need to: 1. (Only for class debugging.) Pass -classdebug to the vsim command. This is already passed by FuseSoC to the generated Makefile automatically. 2. Run Questa Sim manually via generated Makefile: enter the generated directory and run make run-gui . 3. In the GUI, look for the class type in the Structure window. Then, open Class Instances via View menu and select class instance. Select Add Wave in right click menu. 4. Class variables are still not logged: to log these, write log -class to the Transcript console and drag the class type to the console. Hit enter. Now restart and rerun the simulation, class variables of class instances of this type will be now logged. Please note that when running Questa Sim GUI manually, no changes will be to the source RTL will be reflected until regenerating the project using FuseSoC and relaunching the Questa. Notes about adding more objects to the log By default, Questa does not log neither class variables nor memories. To do that in GUI, log <...> command is used in the Transcript console. It can be done also when using the CLI: you need to add one or more of these commands to the 'do' files or specify them directly in the -do argument. The second method is used in this project as well. Because FuseSoC allows to specify arbitrary extra command to be passed to vsim and Questa allows more -do arguments in a single invocation, we can misuse the FuseSoC's functionality to inject our own 'do' commands. This is perfect for configuring the simulator to our liking, such as adding more objects to be logged. Although this method can be fragile (change of Questa or FuseSoC will break it), it does not require any changes to FuseSoC or any manual copying to a project generated by FuseSoC. Also, this method allows way quicker debugging - on every change to RTL, you only need to recompile a relaunch simulation using FuseSoC and hit Refresh button in vsim viewer -- no need to relaunch Questa every time as is needed in interactive GUI sessions.","title":"Debugging in simulation"},{"location":"debugging/#debugging-in-simulation","text":"For simulation we use Mentor's Questa Sim (formerly known as Modelsim), because Xilinx's xsim was deemed to be insufficient for the project, mainly because of random fatal errors with no further information when using SystemVerilog interface expressions. Other simulators from the 'top 3' should work as well: Synopsys VCS and Cadence Xcelium. To use these, just add appropriate configuration to the FuseSoC core file.","title":"Debugging in simulation"},{"location":"debugging/#prerequisites","text":"The project uses Xilinx's IP. Xilinx's own simulator, xsim, links all of these automatically. However, we use a third-party simulator, Questa Sim, where we need to specify paths to those IPs manually. Sadly all of them are non-public, this means that you need to obtain them by yourself (by default all of them are included in Vivado installation) and edit paths in FuseSoC. Before proceeding, change all paths in xilinx_ip fileset in FuseSoC core file according to your installation. Don't commit these changes.","title":"Prerequisites"},{"location":"debugging/#running-a-simulation","text":"To generate simulation configuration, we use FuseSoC. To run a unit testbench, use target with the name of the unit testbench you want to run (have a look at the wb_modules.core ): fusesoc run --target xpm_ram_tb wb-modules This command will generate a project in build directory and run a simulation. The simulation will output a log to the console and to a transcript file. Also, waveform log will be produced, by default to a vsim.wlf file. This file contains logs of all static signals except memories and is viewable by using command vsim -view vsim.wlf . If you make any changes to the RTL when viewing the log, just relaunch FuseSoC and after the simulation finished, just click Refresh button in vsim; all data will be updated.","title":"Running a simulation"},{"location":"debugging/#debugging-classes-or-memories","text":"Note that no class variables (or memories) are logged to the waveform log, unless they are explicitly specified. Some of these are already specified in the FuseSoC core file. To specify more (or newly created classes) or memories, launch the GUI and find signal names. After that, you can continue to debug using the GUI or add the crafted log commands to the FuseSoC config for the signals to be always included in the wlf file. To debug classes/memories with Questa Sim GUI, you need to: 1. (Only for class debugging.) Pass -classdebug to the vsim command. This is already passed by FuseSoC to the generated Makefile automatically. 2. Run Questa Sim manually via generated Makefile: enter the generated directory and run make run-gui . 3. In the GUI, look for the class type in the Structure window. Then, open Class Instances via View menu and select class instance. Select Add Wave in right click menu. 4. Class variables are still not logged: to log these, write log -class to the Transcript console and drag the class type to the console. Hit enter. Now restart and rerun the simulation, class variables of class instances of this type will be now logged. Please note that when running Questa Sim GUI manually, no changes will be to the source RTL will be reflected until regenerating the project using FuseSoC and relaunching the Questa.","title":"Debugging classes or memories"},{"location":"debugging/#notes-about-adding-more-objects-to-the-log","text":"By default, Questa does not log neither class variables nor memories. To do that in GUI, log <...> command is used in the Transcript console. It can be done also when using the CLI: you need to add one or more of these commands to the 'do' files or specify them directly in the -do argument. The second method is used in this project as well. Because FuseSoC allows to specify arbitrary extra command to be passed to vsim and Questa allows more -do arguments in a single invocation, we can misuse the FuseSoC's functionality to inject our own 'do' commands. This is perfect for configuring the simulator to our liking, such as adding more objects to be logged. Although this method can be fragile (change of Questa or FuseSoC will break it), it does not require any changes to FuseSoC or any manual copying to a project generated by FuseSoC. Also, this method allows way quicker debugging - on every change to RTL, you only need to recompile a relaunch simulation using FuseSoC and hit Refresh button in vsim viewer -- no need to relaunch Questa every time as is needed in interactive GUI sessions.","title":"Notes about adding more objects to the log"},{"location":"modules/","text":"Module documentation XPM RAM Module name: wb_xpm_ram This module implements a basic parametrizable XPM RAM SLAVE module. Here are relevant parameters as dictated by Wishbone specification B4: Parameter Value Wishbone revision B4 Interface type SLAVE Supported cycles SLAVE, READ/WRITE Data port size Variable, default 32 bit Data port granularity Variable, default 8 bit Data port max size Dictated by XPM macro, for 2024.1 version it is 4608 bits Data transfer ordering Little endian 32-bit GPIO Module name: wb_gpio This module implements a 32-bit wide GPIO ports. Parameter Value Wishbone revision B4 Interface type SLAVE Supported cycles SLAVE, (pipelined) READ/WRITE Data port size 32 bit Data port granularity 32 bit (byte or half word access not supported) Data port max size 32 bit Data transfer ordering Little endian GPIO consists of 3 registers: direction register, read data register and write data register. GPIO register set is word-addressable only. Only lower 4 bits of address are decoded. X means don't care. Address Access Register 4'b00XX R/W direction 4'b01XX R/W data to be output on ports 4'b10XX R data read from ports Direction register drives all 32 ports, meaning each bit controls one port. Directions are encoded as following: 0 : input 1 : output SOSIF Module name: wb_sosif This block implements an interface between any Wishbone master (e.g. CPU) and an RTL simulator. This block is obviously non-synthesizable. Parameter Value Wishbone revision B4 Interface type SLAVE Supported cycles SLAVE, READ/WRITE Data port size 32 bit Data port granularity 32 bit (byte or half word access not supported) Data port max size 32 bit Data transfer ordering Little endian Usage It is possible to use this interface for example as a way of communication between simulated CPU and an RTL simulator. For now, the interface supports halting the simulation and sending messages to be printed to the log. The SOSIF is available via a single write-only memory mapped register. Address depends on your interconnect configuration. The SOSIF is interfaced by writing a word to this address. The word contains a command (OP) and optionally some arguments. Following table describes format of the word for every supported command: Command Byte 3 Byte 2 Byte 1 Byte 0 Halt simulation, no status 00 00 00 01 Halt simulation with test passed 00 00 00 02 Halt simulation with test failed 00 00 00 03 Put character to msg buffer 00 00 <character> 10 Flush buffer with $info 00 00 00 11 Flush buffer with $warning 00 00 00 12 Flush buffer with $error 00 00 00 13 Examples: To terminate the simulation without any additional message, write 0x00000001 . To put character 'A' to a message buffer and then print it using SystemVerilog's $info , write 0x00004110 and then 0x00000011 . PWM Module name: wb_pwm This block implements very simple 12-bit PWM outputs. Parameter Value Wishbone revision B4 Interface type SLAVE Supported cycles SLAVE, (pipelined) READ/WRITE Data port size 32 bit Data port granularity 32 bit (byte or half word access not supported) Data port max size 32 bit Data transfer ordering Little endian The PWM block contains a variable number of 12-bit PWMs. The number of PWMs is configurable via PWM_PORT_CNT and must be even. Depending on PWM count, there will be ( PWM_PORT_CNT /2) number of 32-bit configuration registers, each register contains a duty cycle configuration of two PWM outputs (called LO and HI) The structure of the register follows: Bits Access Content 31-28 - - 27-16 R/W PWM HI duty cycle 15-12 - - 11-0 R/W PWM LO duty cycle The registers are mapped to addresses in sequential manner. For example, if PWM_PORT_CNT is 8, there will be 4 registers available at these addresses: 32'hxxxx_xxx0 32'hxxxx_xxx4 32'hxxxx_xxx8 32'hxxxx_xxxC where 'x' means don't care -- this part of address will be mapped by your interconnect. Debouncer Module name: wb_debouncer The debouncer block is useful for denoising external user inputs, such as buttons (often present on learning FPGA boards, such as Basys 3, Zybo, Nexys Video...). The debouncer contains variable number of outputs (configurable by PORT_CNT parameter, up to 32). The width of debouncing timer is configurable ( TIMER_WIDTH ). It is recommended to configure this parameter depending on clock speed. The debouncer works as following: if change on input is detected, a timer will be started. If timer reaches top (see note), input will be passed to output. However, if a change is detected before timer reaches top, the timer will be restarted and the process is repeated. Note: to spare some logic, only top bit of the timer is checked. As such, the real length of timer is roughly one bit lower. TIMER_WIDTH should be calculated as following: TIMER_WIDTH = ceil(log2(largest_gap_between_bounces * clock_speed)) + 1 The default value (22) is calculated for 100 MHz clock and ~20 ms gap between bounces. Parameter Value Wishbone revision B4 Interface type SLAVE Supported cycles SLAVE, (pipelined) READ/WRITE Data port size 32 bit Data port granularity 32 bit (byte or half word access not supported) Data port max size 32 bit Data transfer ordering Little endian There is only one read-only register, where each bit represents a single input. It there is less than 32 inputs configured, bits will be mapped LSB-first, the others will be read-only zero. RISC-V compliant machine timer Module name: wb_riscv_timer This module implements a 64-bit timer with IRQ output which complies to the RISC-V Privileged Specification. There is only one parameter: CLK_FREQUENCY_HZ, which should be set to a frequency of the system clock. It is used by the platform to determine timer tick frequency as required by the specification. Parameter Value Wishbone revision B4 Interface type SLAVE Supported cycles SLAVE, (pipelined) READ/WRITE Data port size 32 bit Data port granularity 32 bit (byte or half word access not supported) Data port max size 32 bit Data transfer ordering Little endian Timer consists of 3 pcs of 64-bit registers: Address Access Register 5'b00HXX R/W mtime (timer value) 5'b01HXX R/W mtimecmp (timer compare register) 5'b10HXX R timer tick frequency Notes: - XX means don't care. Because granularity is 32-bit, all 4 byte offsets will return the same value. - H is decoded as low/high word selector. Because registers are 64-bit (for all architectures) and the bus is only 32-bit, this selector bit is required. - Timer tick is actually a constant set by the CLK_FREQUENCY_HZ. There is an IRQ output, which is triggered when mtime >= mtimecmp and stays until this condition is true.","title":"Module documentation"},{"location":"modules/#module-documentation","text":"","title":"Module documentation"},{"location":"modules/#xpm-ram","text":"Module name: wb_xpm_ram This module implements a basic parametrizable XPM RAM SLAVE module. Here are relevant parameters as dictated by Wishbone specification B4: Parameter Value Wishbone revision B4 Interface type SLAVE Supported cycles SLAVE, READ/WRITE Data port size Variable, default 32 bit Data port granularity Variable, default 8 bit Data port max size Dictated by XPM macro, for 2024.1 version it is 4608 bits Data transfer ordering Little endian","title":"XPM RAM"},{"location":"modules/#32-bit-gpio","text":"Module name: wb_gpio This module implements a 32-bit wide GPIO ports. Parameter Value Wishbone revision B4 Interface type SLAVE Supported cycles SLAVE, (pipelined) READ/WRITE Data port size 32 bit Data port granularity 32 bit (byte or half word access not supported) Data port max size 32 bit Data transfer ordering Little endian GPIO consists of 3 registers: direction register, read data register and write data register. GPIO register set is word-addressable only. Only lower 4 bits of address are decoded. X means don't care. Address Access Register 4'b00XX R/W direction 4'b01XX R/W data to be output on ports 4'b10XX R data read from ports Direction register drives all 32 ports, meaning each bit controls one port. Directions are encoded as following: 0 : input 1 : output","title":"32-bit GPIO"},{"location":"modules/#sosif","text":"Module name: wb_sosif This block implements an interface between any Wishbone master (e.g. CPU) and an RTL simulator. This block is obviously non-synthesizable. Parameter Value Wishbone revision B4 Interface type SLAVE Supported cycles SLAVE, READ/WRITE Data port size 32 bit Data port granularity 32 bit (byte or half word access not supported) Data port max size 32 bit Data transfer ordering Little endian","title":"SOSIF"},{"location":"modules/#usage","text":"It is possible to use this interface for example as a way of communication between simulated CPU and an RTL simulator. For now, the interface supports halting the simulation and sending messages to be printed to the log. The SOSIF is available via a single write-only memory mapped register. Address depends on your interconnect configuration. The SOSIF is interfaced by writing a word to this address. The word contains a command (OP) and optionally some arguments. Following table describes format of the word for every supported command: Command Byte 3 Byte 2 Byte 1 Byte 0 Halt simulation, no status 00 00 00 01 Halt simulation with test passed 00 00 00 02 Halt simulation with test failed 00 00 00 03 Put character to msg buffer 00 00 <character> 10 Flush buffer with $info 00 00 00 11 Flush buffer with $warning 00 00 00 12 Flush buffer with $error 00 00 00 13 Examples: To terminate the simulation without any additional message, write 0x00000001 . To put character 'A' to a message buffer and then print it using SystemVerilog's $info , write 0x00004110 and then 0x00000011 .","title":"Usage"},{"location":"modules/#pwm","text":"Module name: wb_pwm This block implements very simple 12-bit PWM outputs. Parameter Value Wishbone revision B4 Interface type SLAVE Supported cycles SLAVE, (pipelined) READ/WRITE Data port size 32 bit Data port granularity 32 bit (byte or half word access not supported) Data port max size 32 bit Data transfer ordering Little endian The PWM block contains a variable number of 12-bit PWMs. The number of PWMs is configurable via PWM_PORT_CNT and must be even. Depending on PWM count, there will be ( PWM_PORT_CNT /2) number of 32-bit configuration registers, each register contains a duty cycle configuration of two PWM outputs (called LO and HI) The structure of the register follows: Bits Access Content 31-28 - - 27-16 R/W PWM HI duty cycle 15-12 - - 11-0 R/W PWM LO duty cycle The registers are mapped to addresses in sequential manner. For example, if PWM_PORT_CNT is 8, there will be 4 registers available at these addresses: 32'hxxxx_xxx0 32'hxxxx_xxx4 32'hxxxx_xxx8 32'hxxxx_xxxC where 'x' means don't care -- this part of address will be mapped by your interconnect.","title":"PWM"},{"location":"modules/#debouncer","text":"Module name: wb_debouncer The debouncer block is useful for denoising external user inputs, such as buttons (often present on learning FPGA boards, such as Basys 3, Zybo, Nexys Video...). The debouncer contains variable number of outputs (configurable by PORT_CNT parameter, up to 32). The width of debouncing timer is configurable ( TIMER_WIDTH ). It is recommended to configure this parameter depending on clock speed. The debouncer works as following: if change on input is detected, a timer will be started. If timer reaches top (see note), input will be passed to output. However, if a change is detected before timer reaches top, the timer will be restarted and the process is repeated. Note: to spare some logic, only top bit of the timer is checked. As such, the real length of timer is roughly one bit lower. TIMER_WIDTH should be calculated as following: TIMER_WIDTH = ceil(log2(largest_gap_between_bounces * clock_speed)) + 1 The default value (22) is calculated for 100 MHz clock and ~20 ms gap between bounces. Parameter Value Wishbone revision B4 Interface type SLAVE Supported cycles SLAVE, (pipelined) READ/WRITE Data port size 32 bit Data port granularity 32 bit (byte or half word access not supported) Data port max size 32 bit Data transfer ordering Little endian There is only one read-only register, where each bit represents a single input. It there is less than 32 inputs configured, bits will be mapped LSB-first, the others will be read-only zero.","title":"Debouncer"},{"location":"modules/#risc-v-compliant-machine-timer","text":"Module name: wb_riscv_timer This module implements a 64-bit timer with IRQ output which complies to the RISC-V Privileged Specification. There is only one parameter: CLK_FREQUENCY_HZ, which should be set to a frequency of the system clock. It is used by the platform to determine timer tick frequency as required by the specification. Parameter Value Wishbone revision B4 Interface type SLAVE Supported cycles SLAVE, (pipelined) READ/WRITE Data port size 32 bit Data port granularity 32 bit (byte or half word access not supported) Data port max size 32 bit Data transfer ordering Little endian Timer consists of 3 pcs of 64-bit registers: Address Access Register 5'b00HXX R/W mtime (timer value) 5'b01HXX R/W mtimecmp (timer compare register) 5'b10HXX R timer tick frequency Notes: - XX means don't care. Because granularity is 32-bit, all 4 byte offsets will return the same value. - H is decoded as low/high word selector. Because registers are 64-bit (for all architectures) and the bus is only 32-bit, this selector bit is required. - Timer tick is actually a constant set by the CLK_FREQUENCY_HZ. There is an IRQ output, which is triggered when mtime >= mtimecmp and stays until this condition is true.","title":"RISC-V compliant machine timer"}]}